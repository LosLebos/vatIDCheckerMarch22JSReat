Object.defineProperty(exports, "__esModule", { value: true });
exports.findPropertiesRead = exports.isMethodReference = exports.findOfficeApiReferences = exports.findTopLevelExpression = exports.isContextSyncIdentifier = void 0;
const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const getFunction_1 = require("./getFunction");
const load_1 = require("./load");
function isContextSyncIdentifier(node) {
    var _a, _b, _c, _d, _e;
    return (node.name === "context" &&
        ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
        ((_c = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === experimental_utils_1.AST_NODE_TYPES.CallExpression &&
        ((_d = node.parent) === null || _d === void 0 ? void 0 : _d.property.type) === experimental_utils_1.AST_NODE_TYPES.Identifier &&
        ((_e = node.parent) === null || _e === void 0 ? void 0 : _e.property.name) === "sync");
}
exports.isContextSyncIdentifier = isContextSyncIdentifier;
function findTopLevelExpression(node) {
    while (node.parent && node.parent.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression) {
        node = node.parent;
    }
    return node;
}
exports.findTopLevelExpression = findTopLevelExpression;
let proxyVariables;
let apiReferences;
function findOfficeApiReferences(scope) {
    proxyVariables = new Set();
    apiReferences = [];
    findOfficeApiReferencesInScope(scope);
    return apiReferences;
}
exports.findOfficeApiReferences = findOfficeApiReferences;
function findOfficeApiReferencesInScope(scope) {
    scope.references.forEach((reference) => {
        const node = reference.identifier;
        if (reference.isWrite() &&
            reference.writeExpr &&
            (0, getFunction_1.isGetFunction)(reference.writeExpr) &&
            reference.resolved) {
            proxyVariables.add(reference.resolved);
            apiReferences.push({ operation: "Get", reference: reference });
        }
        else if (isContextSyncIdentifier(reference.identifier)) {
            apiReferences.push({ operation: "Sync", reference: reference });
        }
        else if (reference.isRead() &&
            reference.resolved &&
            proxyVariables.has(reference.resolved)) {
            if ((0, load_1.isLoadReference)(node)) {
                apiReferences.push({ operation: "Load", reference: reference });
            }
            else if (isMethodReference(node)) {
                apiReferences.push({ operation: "Method", reference: reference });
            }
            else {
                apiReferences.push({ operation: "Read", reference: reference });
            }
        }
    });
    scope.childScopes.forEach(findOfficeApiReferencesInScope);
}
function isMethod(node) {
    var _a;
    const topExpression = findTopLevelExpression(node);
    return (((_a = topExpression.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.AST_NODE_TYPES.CallExpression &&
        topExpression.parent.callee === topExpression);
}
function isMethodReference(node) {
    return (node.parent &&
        node.parent.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.MemberExpression &&
        isMethod(node.parent));
}
exports.isMethodReference = isMethodReference;
function findPropertiesRead(node) {
    let propertyName = ""; // Will be a string combined with '/' for the case of navigation properties
    while (node) {
        if (node.type === experimental_utils_1.AST_NODE_TYPES.MemberExpression &&
            node.property.type === experimental_utils_1.AST_NODE_TYPES.Identifier &&
            !isMethod(node)) {
            propertyName += node.property.name + "/";
        }
        node = node.parent;
    }
    return propertyName.slice(0, -1);
}
exports.findPropertiesRead = findPropertiesRead;
//# sourceMappingURL=utils.js.map