const experimental_utils_1 = require("@typescript-eslint/experimental-utils");
const load_1 = require("../utils/load");
const utils_1 = require("../utils/utils");
const getFunction_1 = require("../utils/getFunction");
module.exports = {
    name: "load-object-before-read",
    meta: {
        type: "problem",
        messages: {
            loadBeforeRead: "An explicit load call on '{{name}}' for property '{{loadValue}}' needs to be made before the property can be read.",
        },
        docs: {
            description: "Before you can read the properties of a proxy object, you must explicitly load the properties.",
            category: "Possible Errors",
            recommended: false,
            url: "https://docs.microsoft.com/office/dev/add-ins/develop/application-specific-api-model#load",
        },
        schema: [],
    },
    create: function (context) {
        function isInsideWriteStatement(node) {
            while (node.parent) {
                node = node.parent;
                if (node.type === experimental_utils_1.TSESTree.AST_NODE_TYPES.AssignmentExpression)
                    return true;
            }
            return false;
        }
        function hasBeenLoaded(node, loadLocation, propertyName) {
            var _a;
            return (loadLocation.has(propertyName) && // If reference came after load, return
                node.range[1] > ((_a = loadLocation.get(propertyName)) !== null && _a !== void 0 ? _a : 0));
        }
        function findLoadBeforeRead(scope) {
            scope.variables.forEach((variable) => {
                let loadLocation = new Map();
                let getFound = false;
                variable.references.forEach((reference) => {
                    var _a, _b, _c;
                    const node = reference.identifier;
                    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === experimental_utils_1.TSESTree.AST_NODE_TYPES.VariableDeclarator) {
                        getFound = false; // In case of reassignment
                        if (node.parent.init && (0, getFunction_1.isGetFunction)(node.parent.init)) {
                            getFound = true;
                            return;
                        }
                    }
                    if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === experimental_utils_1.TSESTree.AST_NODE_TYPES.AssignmentExpression) {
                        getFound = false; // In case of reassignment
                        if ((0, getFunction_1.isGetFunction)(node.parent.right)) {
                            getFound = true;
                            return;
                        }
                    }
                    if (!getFound) {
                        // If reference was not related to a previous get
                        return;
                    }
                    if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) === experimental_utils_1.TSESTree.AST_NODE_TYPES.MemberExpression) {
                        if ((0, load_1.isLoadFunction)(node.parent)) {
                            // In case it is a load function
                            const propertyNames = (0, load_1.parseLoadArguments)(node.parent);
                            propertyNames.forEach((propertyName) => {
                                loadLocation.set(propertyName, node.range[1]);
                            });
                            return;
                        }
                    }
                    const propertyName = (0, utils_1.findPropertiesRead)(node.parent);
                    if (!propertyName ||
                        hasBeenLoaded(node, loadLocation, propertyName) ||
                        hasBeenLoaded(node, loadLocation, "*") ||
                        isInsideWriteStatement(node)) {
                        return;
                    }
                    context.report({
                        node: node,
                        messageId: "loadBeforeRead",
                        data: { name: node.name, loadValue: propertyName },
                    });
                });
            });
            scope.childScopes.forEach(findLoadBeforeRead);
        }
        return {
            Program() {
                findLoadBeforeRead(context.getScope());
            },
        };
    },
};
//# sourceMappingURL=load-object-before-read.js.map