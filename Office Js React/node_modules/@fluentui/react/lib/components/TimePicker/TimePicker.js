import { __assign, __rest } from "tslib";
import * as React from 'react';
import { KeyCodes } from '../../Utilities';
import { TimeConstants, addMinutes, formatTimeString, ceilMinuteToIncrement } from '@fluentui/date-time-utilities';
import { ComboBox } from '../../ComboBox';
var REGEX_SHOW_SECONDS_HOUR_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]):(?:[0-5]\d) ?([AaPp][Mm]))$/;
var REGEX_HIDE_SECONDS_HOUR_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))$/;
var REGEX_SHOW_SECONDS_HOUR_24 = /([0-9]|0[0-9]|1[0-9]|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$/;
var REGEX_HIDE_SECONDS_HOUR_24 = /([0-9]|0[0-9]|1[0-9]|2[0-3]):(?:[0-5]\d)$/;
var TIME_LOWER_BOUND = 0;
var TIME_UPPER_BOUND = 23;
var getDefaultStrings = function (useHour12, showSeconds) {
    var errorMessageToDisplay = '';
    var hourUnits = useHour12 ? '12-hour' : '24-hour';
    showSeconds
        ? (errorMessageToDisplay = "TimePicker format must be valid and in the " + hourUnits + " " + "format hh:mm:ss A.")
        : (errorMessageToDisplay = "TimePicker format must be valid and in the " + hourUnits + " " + "format hh:mm A.");
    return {
        invalidInputErrorMessage: errorMessageToDisplay,
    };
};
export var TimePicker = function (_a) {
    var label = _a.label, _b = _a.increments, increments = _b === void 0 ? 30 : _b, _c = _a.showSeconds, showSeconds = _c === void 0 ? false : _c, _d = _a.allowFreeform, allowFreeform = _d === void 0 ? true : _d, _e = _a.useHour12, useHour12 = _e === void 0 ? false : _e, timeRange = _a.timeRange, _f = _a.strings, strings = _f === void 0 ? getDefaultStrings(useHour12, showSeconds) : _f, onFormatDate = _a.onFormatDate, onValidateUserInput = _a.onValidateUserInput, onChange = _a.onChange, rest = __rest(_a, ["label", "increments", "showSeconds", "allowFreeform", "useHour12", "timeRange", "strings", "onFormatDate", "onValidateUserInput", "onChange"]);
    var _g = React.useState(''), userText = _g[0], setUserText = _g[1];
    var _h = React.useState(''), errorMessage = _h[0], setErrorMessage = _h[1];
    var optionsCount = getDropdownOptionsCount(increments, timeRange);
    var timePickerOptions = React.useMemo(function () {
        var optionsList = Array(optionsCount);
        for (var i = 0; i < optionsCount; i++) {
            optionsList[i] = 0;
        }
        var defaultTime = generateDefaultTime(increments, timeRange);
        return optionsList.map(function (_, index) {
            var option = addMinutes(defaultTime, increments * index);
            option.setSeconds(0);
            var optionText = onFormatDate ? onFormatDate(option) : formatTimeString(option, showSeconds, useHour12);
            return {
                key: optionText,
                text: optionText,
            };
        });
    }, [timeRange, increments, optionsCount, showSeconds, onFormatDate, useHour12]);
    var _j = React.useState(timePickerOptions[0].key), selectedKey = _j[0], setSelectedKey = _j[1];
    var onInputChange = React.useCallback(function (event, option, index, value) {
        if (onChange) {
            onChange(event, option, index, value);
        }
        var validateUserInput = function (userInput) {
            var errorMessageToDisplay = '';
            var regex;
            if (useHour12) {
                regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_12 : REGEX_HIDE_SECONDS_HOUR_12;
            }
            else {
                regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_24 : REGEX_HIDE_SECONDS_HOUR_24;
            }
            if (!regex.test(userInput)) {
                errorMessageToDisplay = strings.invalidInputErrorMessage;
            }
            return errorMessageToDisplay;
        };
        var key = option === null || option === void 0 ? void 0 : option.key;
        var updatedUserText = '';
        var errorMessageToDisplay = '';
        if (value) {
            if (allowFreeform && !option) {
                if (!onFormatDate) {
                    // Validate only if user did not add onFormatDate
                    errorMessageToDisplay = validateUserInput(value);
                }
                else {
                    // Use user provided validation if onFormatDate is provided
                    if (onValidateUserInput) {
                        errorMessageToDisplay = onValidateUserInput(value);
                    }
                }
            }
            updatedUserText = value;
        }
        else if (option) {
            updatedUserText = option.text;
        }
        setErrorMessage(errorMessageToDisplay);
        setUserText(updatedUserText);
        setSelectedKey(key);
    }, [
        allowFreeform,
        onFormatDate,
        onValidateUserInput,
        showSeconds,
        useHour12,
        onChange,
        strings.invalidInputErrorMessage,
    ]);
    var evaluatePressedKey = function (event) {
        if (!onFormatDate &&
            // Only permit input of digits, space, colon, A/P/M characters
            !((event.charCode >= KeyCodes.zero && event.charCode <= KeyCodes.colon) ||
                event.charCode === KeyCodes.space ||
                event.charCode === KeyCodes.a ||
                event.charCode === KeyCodes.m ||
                event.charCode === KeyCodes.p)) {
            event.preventDefault();
        }
    };
    return (React.createElement(ComboBox, __assign({}, rest, { allowFreeform: allowFreeform, selectedKey: selectedKey, label: label, errorMessage: errorMessage, options: timePickerOptions, onChange: onInputChange, text: userText, 
        //eslint-disable-next-line
        onKeyPress: evaluatePressedKey })));
};
TimePicker.displayName = 'TimePicker';
var clampTimeRange = function (timeRange) {
    return {
        start: Math.min(Math.max(timeRange.start, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
        end: Math.min(Math.max(timeRange.end, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
    };
};
var generateDefaultTime = function (increments, timeRange) {
    var newDefaultTime = new Date();
    if (timeRange) {
        var clampedTimeRange = clampTimeRange(timeRange);
        newDefaultTime.setHours(clampedTimeRange.start);
    }
    return ceilMinuteToIncrement(newDefaultTime, increments);
};
var getDropdownOptionsCount = function (increments, timeRange) {
    var hoursInRange = TimeConstants.HoursInOneDay;
    if (timeRange) {
        var clampedTimeRange = clampTimeRange(timeRange);
        if (clampedTimeRange.start > clampedTimeRange.end) {
            hoursInRange = TimeConstants.HoursInOneDay - timeRange.start - timeRange.end;
        }
        else if (timeRange.end > timeRange.start) {
            hoursInRange = timeRange.end - timeRange.start;
        }
    }
    return Math.floor((TimeConstants.MinutesInOneHour * hoursInRange) / increments);
};
//# sourceMappingURL=TimePicker.js.map